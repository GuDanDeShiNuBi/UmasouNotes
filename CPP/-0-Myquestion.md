### *__疑问点__*


* " >> "和" << "
  * " >> " 运算符是输入运算符，它从控制台或文件中读取数据，并将其存储在变量中
  * " << " 运算符是输出运算符，它将变量的值输出到控制台或文件中
  * 在I/O中，" >> " 和" << " 运算符都需要左操作数是std::istream或std::ostream类型

* 源文件中包含了iostream 为什么不能直接使用istream
  * 源文件中包含iostream头文件后，可以直接使用std命名空间下的std::cout、std::cin等标准I/O流、以及其他标准库的类和函数。但是，在源文件中仍然需要特别说明std::istream类型，而不能直接使用istream类型。这是因为iostream头文件中包含了iostream标准命名空间，而std::istream是iostream标准命名空间下的一个类

* 为什么常量对象只能调用常量成员函数
  * 常量对象是指其数据成员的值不能被修改的对象，即其成员变量均为const类型或者该对象被声明为const类型。而常量成员函数是指在函数声明中加上了const修饰符的成员函数，表示该函数不会修改类对象的状态。
  * 常量对象只能调用常量成员函数，这是因为常量对象在编译期就被确定了其值，无法被修改，因此如果调用非常量成员函数可能会导致编译错误。而常量成员函数保证了不会修改类对象的状态，可以对常量对象进行调用。
  * 除此之外，对于常量对象调用非常量成员函数的行为也是不安全的，因为非常量成员函数可能会修改类对象的状态，导致常量对象的值被改变，这违反了常量对象的定义。因此，将非常量成员函数修改为常量成员函数可以保证类对象的数据成员的值不会被改变，进而保证了程序的正确性。

* 块作用域
  * 块作用域是指在一对花括号 "{" 和 "}" 之间的区域，通常用于限定变量、函数和对象的作用域。一旦超出这个区域，就无法再访问在其中定义的变量、函数和对象。块作用域可以嵌套，也就是说，在一个块作用域中可以定义另一个块作用域。

* 变量初始化
  * 变量的初始化是通过构造函数来完成的，而基本数据类型的初始化只是被值拷贝给了对象，而自定义类型需要执行构造函数来为对象分配内存并复制初始值。

* 将一个值拷贝到对象的底层逻辑
  * 在将一个值拷贝到对象中之前，需要先为对象分配内存空间，然后编译器会将变量值拷贝到对象的内存空间中。这个过程在语言底层是由运算符重载机制来实现的。

* C++ 引用是怎么跟初始值绑定一起的
  * 当我们为引用变量赋初值时，编译器会将引用变量的地址设置为初始变量或对象的地址，这样，引用变量就指向了初始变量或对象的地址。也就是说，引用变量本身并不持有实际的值，只是指向了其它变量或对象的内存地址。

* C++引用为什么必须初始化
  * 引用必须在声明时进行初始化是因为引用本质上是一个别名，它和被引用的变量是同一个变量，它不占用内存空间。所以当我们声明一个引用时，需要为其指定一个初始变量，使之引用该变量，否则会产生编译错误。
  * 1. 引用本质上是一个被const指针所规定的别名，它占用的内存空间与普通变量相同，因此需要进行初始化。
  * 2. 引用在使用过程中，必须随时关联到某个变量，而初始化提供了将引用关联到某个变量的方式。
  * 3. 如果在声明引用时未初始化，则编译器不知道该引用的指向，该引用不会分配内存，这会导致编译错误。

* 指针与引用的区别
  1. 差别在于内存处理方式：指针是一个变量，存储内存地址，可以被修改。而引用本质上是一个别名或者一个别名变量，并不占用内存空间，只是为已存在的变量起了一个别名。
  2. 差别在于使用的方式：指针通过地址访问数据，使用时需要取地址、解引用等一系列复杂的操作。而引用可以直接访问数据，使用时像使用变量名一样，更简单方便。
  3. 差别在于空值处理方式：指针可以被赋予空指针的值，表示它不指向任何有效的内存。引用不能被赋空值，必须在定义时初始化。
  4. 差别在于传递方式：指针传递形式为传递指针的地址，接收方为指针；引用则是直接传递引用变量，接收方为引用类型。

* #include 与using
  * #include用于引入头文件，而using用于引入命名空间成员

* 形参与实参
  * 形参是函数定义中的参数列表中声明的参数
  * 实参是函数调用时提供给函数的具体值或引用

* 关于size_type
  * 在C++的标准库中，size_type是std::string类的一个内部类型。
  * size_type是一个无符号整数类型，用于表示字符串（std::string）的大小或索引。它通常被用作索引、位置和大小相关的变量或返回类型
  *  std::string::size_type length ;//size_type被用来声明变量length
  *  for (std::string::size_type i = 0; i < length; ++i) {};//在循环中，size_type被用来作为遍历字符串的索引类型。
  *  在 C# 中，没有类似于 C++ 的 size_type 类型。相反，C# 中的字符串大小或字符数量常用 int 类型来表示。由于 C# 中的字符串和数组大小都受到范围限制，并且在实际应用中很少会超出 int 类型的范围，因此直接使用 int 类型来表示字符串的大小或字符数量是合理的。

* 为什么string与IO类型不是字面值类型
  * 字面值类型是指可以直接使用字面值（literal）进行赋值或初始化的类型。例如，整数类型、浮点数类型、字符类型和布尔类型都可以使用字面值进行初始化，例如 int x = 10;、 float f = 3.14f;、char c = 'A';、bool b = true;
  * 而对于 std::string 类型和IO类型，它们并不是直接使用字面值进行初始化的。比如，在创建一个 std::string 对象时，我们需要使用构造函数将字面值转换为 std::string 对象，例如 std::string str("hello");。同样，对于IO类型，我们需要使用特定的函数或操作符重载来实现输入输出操作，例如 std::cout << "Hello, world!" << std::endl;。

* void Func(int (&arr)[10])与void Func(int (arr)[10])的区别
  * 即数组引用形参与数组形参的区别
  * void Func(int (&arr)[10]) 使用了引用（&）来传递数组参数。这意味着在函数内部对该数组的任何修改都会反映到函数外部的原始数组上。换句话说，使用引用传递数组参数可以对原始数组进行修改。
  * 而 void Func(int (arr)[10]) 则没有使用引用。这意味着在函数内部对数组的修改仅在函数内部有效，不会影响到函数外部的原始数组。

* *beg++
  * const int *beg; cout<<*beg;
  * 上面程序的含义：beg指向x的地址，并且是一个常量指针，你可以通过*beg来获取指针所指向的整数值：
  * *beg++是一个复合表达式，具体执行步骤如下：
    * *beg：获取指针beg所指向位置的值。
    * beg++：将指针beg向后移动到下一个元素。
    * *beg++等效于*(beg++)。

* index + 1 和 index++ 的区别：
  * 都是对索引进行递增操作，但它们有一些区别。
  * index + 1 ：这是一个表达式，其结果是将索引值加 1，但不会改变原始的索引值。也就是说，index + 1 表达式返回 index 加上 1 后的值，而不会修改 index 的原始值。
  * index++ ：这是一个后缀自增运算符，它会先返回当前的索引值，然后再将索引值加 1。也就是说，index++ 表达式会返回 index 的原始值，然后将 index 的值加 1。因此，index 的值在后缀自增运算符执行后会被修改。


* 函数返回一个对象，与返回一个对象引用的区别
  * 当函数返回一个对象时，它会创建这个对象的副本，并将副本作为函数的返回值。这意味着在函数调用结束后，我们获得了一个独立的、与原始对象相等但完全独立的新对象
  * 当函数返回一个对象引用时，它会返回原始对象的别名或引用，该别名或引用可以直接访问和操作原始对象

* 直接初始化与拷贝类型初始化
  * 直接初始化允许进行隐式类型转换，因为它在构造函数调用时允许单个参数的构造函数隐式地将实参转换为需要的类型。它可以使用圆括号或大括号来初始化对象。int num1(10);
  * 拷贝形式的初始化通过使用等号=将一个对象的值赋给另一个对象，执行对象之间的逐个成员拷贝。它不允许隐式类型转换，要求对象的类型必须完全匹配或可以通过构造函数进行显式转换。int num3=num1;