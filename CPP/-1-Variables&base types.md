
### *__变量与基础类型__*

__ _


* 引用
  * 为对象起了另外一个名字。一般在初始化变量时，初始值会被拷贝到新建的对象中，然而定义引用时，程序将引用与它的初始值绑定在一起，而不是将初始值拷贝给引用
    * > int val=1024;
    * > int &refVal=val;
    * > int & refVal2;  //报错，引用必须初始化
    * 引用并非对象，引用即别名
  * 引用的定义
    * 引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起
    * > int &refVal=10; //错误，初始值不能为字面值
    * 引用本身没有分配内存，它只是一个已存在变量的别名，所以引用不需要进行内存管理。
    * 引用是对变量的直接访问，对引用的任何操作都会修改所引用的变量的值。
    * 引用在函数中作为参数传递时，可以将参数视为传引用。这意味着在函数调用中，传递的仅仅是变量的引用而不是复制变量本身。
    * 引用在函数返回时可以作为返回值，这意味着函数所返回的值是原始变量的别名，而不是一个新创建的副本。
  * cosnt的引用
    * 引用的类型必须与其所引用对象的类型一致，但有两个例外。第一个是初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。例如，允许一个常量引用绑定非常量的对象、字面值、表达式
      * > const int &r=42

* 指针
  * 指针本身就是一个对象，且无须在定义时赋初值。
  * 指针声明符写成*d的形式，d为变量名。如果一个语句中定义了几个指针变量，每个变量前都必须由符号 *；
  * 某些符号有多重含义
    * >int i=42;
    * >int &r=i;//&紧跟类型名出现，是声明的一部分，r是一个引用
    * >int *p; // *紧跟类型名出现，是声明的一部分，p是一个指针
    * >p=&i; //&出现在表达式中，是一个取地址符
    * >*p=i; // *出现在表达式中，是一个解引用符
    * >int &r2=*p  //&是声明的一部分，*是一个解引用符  
  * void*:特殊指针类型，可用于存放任意对象的地址
  * 指针表达式：*p++
    * cout<<*p++;
    * 等价于 cout<<*p;++p;

* 当对象的声明过于复杂时，可采用从右往左的读法

* const
  * 使用关键字const对变量的类型加以限定，如：const int bufsize=512;const对象创建时必须进行初始化，固定其缓冲区的大小，且创建后其值不能被改变。
  * 因为默认情况下，const对象被设定为仅在当前文件有效，为了其他文件声明并使用它，可cosnt前加extern关键字
  * 指针与const
    * 指向常量的指针
      * 不能改变其所指对象的值。要想存放常量对象的地址，只能使用指向常量的指针
      * 指向常量的指针可以指向一个非常量对象，它所代表的仅仅是不能通过该指针改变对象的值。
      * > const double *cptr=&p;
    * const指针
      * 指针是对象而引用不是，所有允许指针本身定为常量。
      * 在const关键字前加*,表明指针是一个常量。
      * 如：int *const curErr=&val;//不变的是指针本身的值而非指向的那个值
      * 指针本身是一个常量并不意味着不能通过指针修改所指对象的值，能否修改完全依赖与所指对象的类型。 
  
  * 顶层const：指针本身是个常量；底层const：指针所指对象是个常量
    * 顶层const可以表示任意的对象是常量，且对任何数据类型都适用
    * > int i=0;
    * > int *const p1=&i; //不能改变p1的值，顶层const
    * > const int  ci=42;  //不能改变ci的值，顶层const
    * > const int *p2=&ci; //允许改变p2的值，底层const
    * > const int *const p3=p2; //靠右的const是顶层，靠左的是底层
    * > const int &r=ci;  //用于声明引用的const都是底层const
    * 当执行拷贝操作时，顶层const不受影响，拷贝操作不会改变被拷贝对象的值，拷入和考出的对象是否是常量没有影响。底层const，执行拷贝操作时，两个对象必须具有相同的底层const资格，或者两个对象的数据类型可以转换。（使用 = 号进行对象的拷贝，其实就是调用了对象的拷贝构造函数，将源对象的值拷贝到目标对象中，而不会改变源对象和目标对象本身的值。拷贝构造函数是一种特殊的构造函数，它用于创建一个对象，并使用另一个同类型的对象来初始化它。如果没有显式地定义拷贝构造函数，则编译器会自动生成一个默认的拷贝构造函数。默认的拷贝构造函数执行的是浅拷贝，即对所有非静态成员变量执行按值拷贝操作，也就是说它将源对象的所有数据成员的值分别复制到目标对象对应的数据成员中，但对于指针等引用类型的成员变量，只会复制其内存地址，这可能会导致对象之间的数据共享，相互影响。因此，如果需要在对象之间进行拷贝时，需要根据实际情况重写拷贝构造函数，实现深度拷贝或禁止对象之间的拷贝操作，以确保对象的值不会因为拷贝操作而被更改。）
  
  * 常量指针与指针常量
    * 常量指针和指针常量都是指针类型，但其含义不同。常量指针旨在保证指针所指向的对象不会被修改，而指针常量则是指针本身不可修改。
    * 常量指针：
      - 声明方式：const int* ptr;
      - 指针指向的对象不能被修改，但指针本身可以被修改；
      - 例如：int a = 10; const int* ptr = &a;，这里指针ptr指向a的地址，但不能通过ptr修改a的值；
      - 常量指针通常用于函数参数列表中，以防止函数修改指针所指向对象的值。
    * 指针常量：
      - 声明方式：int* const ptr;
      - 指针指向的对象可以被修改，但指针本身不可被修改；
      - 例如：int a = 10; int* const ptr = &a;，这里指针ptr指向a的地址，且可以通过ptr修改a的值，但指针本身不可被修改；
      - 指针常量通常用于指向固定内存地址的指针，例如硬件控制器等。
 
  * 常量表达式：指的是值不会改变且在编译过程就能得到计算结果的表达式
    * constexpr:声明为constexpr的变量一定是一个常量，而且必须由常量表达式初始化
    * 指针与constexpr。
      * const int *p=nullptr;//此时p是一个指向常量的指针
      * constexpr int *q=nullptr;//q是一个指向整数的常量指针
  * const修饰函数本身
    * 当我们在函数声明或定义中，在函数后面加上const时，则表示该函数在类中被定义为一个常量成员函数。常量成员函数不会修改成员变量的值。
    * > int getValue() const { return m_value; }

* 处理类型
  * 类型别名
    * 是某种类型的同义词,使用关键词typedef
      * > typedef double wages;  //wages是double的同义词
      * > typedef wages base ,*p ; //base是double的同义词，p是double*的同义词
      * 含有typedef的声明语句定义的不再是变量二是类型别名
    * using SI=Sales_item;//SI是Sales_item的同义词
    * wages hourly,weekly;//等价于double hourly、weekly

* 头文件  
  * 为了确保各个文件中类的定义一致，类通常被定义在头文件中，而且类所在头文件的名字应与类的名字一样。例如，库类型string在名为string的头文件中定义。
  * 头文件也经常用到其他头文件的功能，所以其他头文件或类也可以包含string.h头文件
  * 头文件保护符
    * 防止同一个头文件被多次包含而导致编译错误，是一种预处理功能，它依赖于预处理变量（已定义与未定义两种状态）
    * ```#ifndef FILENAME_H
         #define FILENAME_H
         //头文件内容
         #endif
      ```
    * 
      ```
      #pragma once
      //头文件内容
      ```

