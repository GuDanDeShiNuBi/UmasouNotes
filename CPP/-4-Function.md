### *__函数__*

___

* 基础
  - 局部静态对象
    - 使局部变量的生命周期贯穿函数调用及之后的时间，程序终止才销毁
  - 函数声明
    - 函数只能定义一次，可以声明多次
    - 函数的声明可以放在头文件中，定义函数的源文件应该把含有函数声明的头文件包含进来，编译器负责验证函数的定义和声明是否匹配
    - 分离式编译

___

* 参数传递
  - 形参初始化的机理与变量初始化一样  
  - 传值参数
    - 当初始化一个非引用类型的变量时，初始值被拷贝给变量，变量的改动不会影响初始值。传值参数的机理与他一样
    - 指针形参
      - 指针的行为和其他非引用类型一样。当执行指针拷贝操作时，拷贝的是指针的值。通过指针可以它所指的对象。
      - > int n=0,i=42;
      - > int *p=&n,*q=&i;//p指向n,q指向i
      - > *p=42;//n的值改变，p不改变
      - > p=q；//p指向了i
      - 指针形参：void reset(int *p)
  - 传引用参数
    - 对于引用的操作实际上作用在引用所引的对象上
      - int &r=n;//r绑定了n,即r是n的另外一个名字
    - 可以通过引用形参，允许函数改变实参的值
      - 引用形参：void reset(int &i)
      - 当拷贝大的类类型对象或容器对象是比较低效，可以使用引用形参访问，避免拷贝
  - cosnt 形参和实参
    - 当用实参初始化形参时会忽略掉顶层const。
      - const int ci=42;
      - int i =ci; //当拷贝ci时，忽略了它的顶层const
    - 形参的初始化方式和变量的初始化方式一样。可参考第一章引用与指针的初始化
    - 尽量使用常量引用，使用普通引用会极大的限制函数所能接受的实参类型，如不能把const对象、字面值、需要类型转换的对象传递给普通的引用形参
  - 数组形参
    - 当函数传递一个数组时，实际上传递的是指向数组首元素的指针
      - > void print(const int *)
      - > void print(consr int[])
      - 这两个函数是等价的
    - 数组以指针的形式传递给函数，所以一开始函数不知道数组的尺寸。管理指针形参有三种常用技术
      - 使用标记指定数据长度 
        ``` 
        void print(const char *cp){
          if(cp) //若cp不是空指针
              while（*cp） //指针所指的字符不是空字符串
                cout<< * cp++;
        }
        ```
      - 使用标准库规范
        ``` 
        void print(const int *beg,const int *end){
              while(beg!=end)
                cout<< *beg++; 
        }  
        ```
      - 显示传递一个表示数组大小的形参
        ``` 
        void print(const int ia[],size_t size){
                for(size_t i=0,i!=size;++i)
                    cout<<ia[i];
        } 
        ```
    - 数组引用形参
      - 变量可以定义成数组的引用，形参也可以是数组的引用，此时，引用形参绑定到对应的实参上，也就是绑定到数组上。
      ``` 
      void print(int(&arr)[10]){
            for(auto elem:arr)
              cout<<elem;
      }
      ```
      - &arr的括号是必须的
    - 传递多维数组
      - 当将多维数组传递给函数时，传递的是指向数组首元素的指针。多维数组指的是数组的数组，所有首元素本身就是一个数组，指针就是一个指向数组的指针。
      - > void print(int (*martrix)[10],int rowsize){};
    - 含有可变形参的函数（为了处理不同数量实参的函数）
      - 1、如果所有实参类型相同，可以传递一个initializer_list的标准库类型
      - 2、可变参数模板
      - 3、使用特殊形参类型，省略符

___        


* 返回类型、return语句
  - 值返回
    - 返回一个值的方式和初始化一个变量或形参的方式一样：返回的值用于初始化调用点的一个临时量，该临时量就函数调用的结果
  - 不要返回局部对象的引用或指针
    - 函数完成后，它所占用的存储空间也随之被释放，局部变量的一样将指向不再有效的内存区域
  - 引用返回左值
    - 左值（Lvalue）：指的是能够被取地址的表达式，通俗的说就是指表达式所代表的变量。例如：变量、数组元素、对象的属性等都是左值。可以对左值进行赋值或者取地址的操作，例如&a或*p=10。
    - 右值（Rvalue）：指的是不能够被取地址的表达式，通常是临时产生的值，没有对应的内存地址。例如：字面值、函数返回值、表达式的结果等都是右值。不能对右值进行赋值操作，只能使用它们的值，例如a+5、++i等。
    - 调用一个返回引用的函数得到左值，其他返回类型得到右值。能为返回类型是非常量引用的函数的结果赋值
  - 返回数组指针
    - 数组不能被拷贝，所有函数不能返回数组，函数可以返回数组的指针或引用。
    - 返回数组的指针或引用的定义比较繁琐，可以使用类型别名
      - > typedef int arrT[10];//arrT是一个类型别名，表示类型是含有10个整数的数组
      - > using arrT=int[10]；//与上面等价
      - > arrT * func(int i);//func返回一个指向含有10个整数的数组指针  
    - 声明一个返回数组指针的函数，不使用类型别名
      - 数组定义
        - > int arr[10]
        - > int (*p2)[10]=&arr
      - 函数定义
        - Type(*func(parameter_list))[dimension] 
        - int(*func(int i))[10]
          - > (*func(int i))意味着我们可以对函数调用的结果执行解引用操作
          - > (*func(int i))[10] 表示解引用func的调用将得到一个大小为10的数组
          - > int(*func(int i))[10] 表示数组的元素是int类型
    - 使用尾置返回类型
      - auto func(int i) - > int(*)[10];
    - 使用decltype
      - 已知函数返回指针指向哪个数组
        - > int odd[]={1,2,3,4};
        - > decltype(odd)*arrPtr(int i);

___

* 函数重载  
  - 同一作用域的几个函数名字相同，形参列表不同（形参数量或类型不同）称为重载 
  - 重载与const形参
    - 顶层const（一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开）
      - > Record lookup(Phone*)
      - > Record lookup(Phone* const);//重复声明
    - 底层const,如果形参是某种类型的指针或引用，通过区分指向的是常量对象还是非常量对象实现重载
      - > Record lookup(Account*);
      - > Record lookup(const Account*);
  - 重载与作用域
    - 在内层作用域声明名字，它将隐藏外层作用域中声明的同名实体

___

* 特殊用途语言特性
  - 默认实参
    - > string screen(int h=24,int w=80)
      - 某个形参被赋予了默认值，它后面的所有形参都必须有默认值
        - > string window;
        - > window =screen(66);//等价于screen(66,80)
        - 只能省略尾部的实参
    - 默认实参声明
      - 给定的作用域中一个形参只能被赋予一次默认实参。函数的后续声明只能为之前没有默认值的形参添加默认实参，而且该形参右侧的所有形参必须都有默认值
    - 局部变量不能作为默认实参
  - 内联函数
    - 函数调用涉及到一些额外的开销，例如将函数参数压入堆栈、函数返回时需要执行回收堆栈等等。对于会被多次调用的小函数而言，这些额外的开销会占用很多时间，因此可以通过内联函数来避免这些开销。内联函数的核心思想是将函数的代码直接嵌入到调用此函数的代码中，而不是在运行时执行函数调用。这就避免了函数调用相关的额外开销，从而提高了程序的性能。
    - 可以避免函数调用的开销
    - 在函数的返回类型前加上关键字inline;
    - 将内联函数的定义放在头文件中，在包含头文件的地方调用该函数时，编译器就会自动将函数代码嵌入到调用处
  - constexpr函数 
    - 指能用于常量表达式的函数，定义constexpr函数，函数的返回类型及所有形参的类型都得是字面值类型，函数体有且只有一条return语句
    - constexpr函数是指在编译阶段可以进行求值的函数，即使没有实例化该函数也可以进行编译时间的求值
    - 内联函数和constexpr函数放在头文件内
- 调试帮助
  - assert预处理宏
    - 预处理宏是一个预处理变量
    - assert(expr);//首先对expr求值，表达式为假（0），assert输出信息并终止程序；为真则继续执行
    - assert宏定义在cassert头文件中。预处理名字由预处理器而非编译器管理，因此可以直接使用预处理名字而无须提供using声明
  - NDEBUG预处理变量
    - NDEBUG 是一个预处理变量，通常用来控制条件编译。当定义了 NDEBUG 时，预处理器禁用了 assert 宏，这意味着你的程序会在执行 assert 操作时直接跳过，而不会输出错误信息。因此，NDEBUG 可以用于在发布阶段禁止调试输出和断言检查，以提高程序的性能和稳定性。

___

* 函数指针
  * 函数指针指向的是函数而非对象，函数指针指向某种特定类型
    * > bool (*pf)(const string &,const string &).
    * 声明一个可以指向某函数的指针，只需要用指针替换函数名即可
  * 使用函数指针
    * 当把函数名作为一个值使用时，函数自动的转换为指针
      * > bool lengthCompare(const string&,const string&);
      * > pf=lengthCompare; //pf指向名为lengthCompare的函数
      * > pf=&lengthCompare; //等价的赋值语句
    * 可以直接使用指向函数的指针调用该函数，无须提前解引用指针
  * 重载函数的指针
    * > void ff(int*);
    * > void ff(unsigned int);
    * > void (*pf1)(unsigned int)=ff; //pf1指向ff(unsigned)
  * 函数指针形参
    * 和数组类似，虽不能定义函数类型形参，但形参可以是指向函数的指针
      * > void udsBigger(const string &s1,cosnt string &s2,bool pf(const string &,const string &));//第三个形参是函数类型，它会自动地转换成指向函数的指针
      * > void udsBigger(const string &s1,cosnt string &s2,bool (*pf)(const string &,const string &));//等价的声明，显示的将形参定义成指向函数的指针
      * > 可以将函数作为实参使用，它会自动转换成指针，useBigger(s1,s2,lengthCompare);
    * 类型别名和decltype能简化使用函数指针的代码
      * > typedef bool Func(const string&,const string&);
      * > typedef decltype(lengthCompare) Func2;
      * > typedef bool *(Funcp)(const string&,const string&);
      * > typedef decltype(lengthCompare) *Funcp2;
      * 使用typedef定义自己的类型。Func和Func2是函数类型，Funcp和Funcp2是指针类型。decltype返回函数类型，不会将函数类型自动转换成指针类型，所有要加*
      * > void useBigger(const string&,const string&,Func);//重新声明useBigger
  * 返回指向函数的指针
    * 和数组类型，不能返回一个函数，但是可以返回一个函数指针，必须将返回类型写成指针形式
      * 使用类型别名
      * > using F =int(int*,int); //F是函数类型，不是指针
      * > using PF=int(*)(int *,int);  //PF是指针类型
      * 返回类型不会自动的转换成指针，必须显式的将返回类型定义为指针
      * > PF f1(int);  //PF是指向函数的指针，f1返回指向函数的指针
      * > F  f1(int);   //错误形式，F是函数类型，f1不能返回一个函数
      * > F *f1(int);   //显式地指定返回类型是指向函数的指针
      * 也可以声明成这种形式：int(*f1(int))(int *,int);//参考返回数组指针的函数定义，由内向外阅读，f1有形参列表，f1是个函数；f1前面有 *，所有f1返回一个指针；最后（int * ，int）说明指针的类型本身也含有形参列表，因此指针指向函数，函数返回类型是int.
    * 还可以使用尾置返回类型方式声明一个返回函数指针的函数
      * > auto f1(int) - >  int (*)(int *，int);
  * 使用decltype用于函数指针类型
    ``` int add(int a, int b) {
          return a + b;
        }
        int main() {
          // 定义函数指针
          int (*func)(int, int) = add;
          // 使用 decltype 获取函数指针类型
          decltype(add)* p = add;
          return 0;
        }
    ```
    * 使用 decltype 获取函数指针类型时返回的是函数类型，需要在函数名后面加上 *，以表示获取的是函数指针类型。