
### *__顺序容器__*

__ _

#### 顺序容器概述

* 顺序容器类型
  * vector   可变大小数组
  * deque    双端队列
  * list     双向链表
  * forword_list    单向链表
  * array    固定大小数组。支持快速随机访问，不能添加删除元素
  * string   与vector相似的容器，但专门用于保存字符
  * 详解
    * string和vector将元素保存在连续的内存空间。由于元素是连续存储的，由元素下标计算地址非常快速，但是添加或删除元素会非常耗时。在一次插入或删除操作后，需要移动插入、删除位置之后的所有元素，来保存连续存储，添加一个元素有时可能还需要分配额外的存储空间，在这种情况下，每个元素都必须移动到新的存储空间
    * list与forword_list令容器任何位置的添加和删除操作都很快速。但作为代价，这两个容器不支持元素的随机访问：为了访问一个元素，我们只能遍历整个容器。而且，与vector\deque\array相比，这两个容器的额外内存开销也很大
    * deque 支持快速的随机访问，在中间位置添加删除元素的代价很高，但在deque的两端添加或删除元素很快
___

#### 容器库概览

* 每个容器定义在一个头文件内，文件名与类型名相同。即，deque定义在头文件deque中。容器均为模板类，我们必须提供额外信息来生成特定的容器类型，如 deque<double>
* 容器操作
  * 类型别名
    * iterator  此容器类型的迭代器类型
    * const_iterator 可以读取元素，但不能修改元素的迭代器类型
    * size_type  无符号整数类型
    * difference_type  带符号整数类型
    * value_type  元素类型
    * reference  元素的左值类型，与value_type含义相同
    * const_reference  元素的const左值类型
  * 构造函数
    * C c   默认构造函数，构造空容器
    * C c1(c2) 构造c2的拷贝c1
    * C c(b,e) 构造c,将迭代器b和e指定的范围内的元素拷贝到c
    * C c(a,b,c)  列表初始化c
  * 赋值与swap
    * c1=c2  将c1中的元素替换为c2中的元素
    * c1={a,b,c} 将c1中的元素替换为列表中元素
    * a.swap(b) 交互a、b的元素
    * swap(a,b) 同上
  * 大小
    * c.size()
    * c.max_size()
    * c.empty() 若c存储了元素，返回false,否则返回true
  * 获取迭代器
    * c.begin(),c.end()  返回指向c的首元素和尾元素之后位置的迭代器
    * c.cbegin(),c.cend() 返回const_iterator
  * 反向容器的额外成员
    * reverse_iterator  按逆序寻址元素的迭代器
    * const_reverse_iterator 不能修改元素的逆序迭代器
    * c.rbegin(),c.rend() 返回执行c的尾元素和首元素之间位置的迭代器
    * c.crbegin(),c.crend() 返回const_reverse_iterator
* 迭代器
  * 迭代器范围由一对迭代器表示
    * [begin,end) //左闭合区间（begin到end之间的元素，包括begin但不包括end）,end指的是尾元素之后的位置
    * 迭代器begin和end必须指向相同的容器
* 容器定义和初始化
  * 每个容器类型都定义了一个默认构造函数，除了array之外，其容器的默认构造函数都会创建一个指定类型的空容器。
  * 将一个容器初始化为另一个容器的拷贝
    * 方法1：直接拷贝整个容器
    * 方法2：拷贝由一个迭代器对指定的元素范围
    * 为了创建一个容器为另一个容器的拷贝，两个容器的类型及其元素类型必须匹配。不过当传递迭代器参数来拷贝一个范围时，就不要求容器类型及元素类型相同了
    * 两个迭代器表示一个范围，可以使用这种构造函数来拷贝一个容器的子序列
      * deque<string>authList(authors.begin(),it);//拷贝元素。直到it指向的元素（不包括it），it表authors中的元素
  * 列表初始化
    * vector<const char*>art={"a","an","the"};
    * 显式地指定了容器中每个元素的值，对于除array之外的容器类型，初始化列表隐含的指定了容器的大小。
  * 与顺序容器大小相关的构造函数
    * 顺序容器（除array）还提供了另外一个构造函数，接受一个容器大小和一个元素初始值
    * vector<int>ivec(10,-1);
    * forward_list<int>ivec(10);//10个元素，初始值为0
  * 标准库array具有固定大小
    * 标准库array的大小也是类型的一部分
    * 当定义一个array时，除了指定元素类型，还要指定容器大小.
    * array<int,42>
    * 内置数组类型不允许进行拷贝或对象赋值操作，但array无此限制
      * int digs[3]={1,2,3};
      * int cpy[3]=digs;  //错误，内置数组不支持
      * array<int,3>digs={1,2,3}
      * array<int,3>cpy=digs;//正确，数组类型及大小匹配即合法
* 赋值和swap
  * 与内置数组不同，标准库array类型运行赋值。左右两边的运算对象必须具有相同的类型
  * 顺序容器（array除外）定义了一个assign的成员，允许完从一个不同但相容的类型赋值，或从容器的一个子序列赋值
    * list<string>names; vector<const char*>oldstyle;
    * names.assign(oldstyle,cbegin(),oldstyle,cend());
  * assign的第二个版本接受一个整型值和一个元素值。它用指定数目且具有相同给定值的元素替换容器原有的元素
    * list<string>slist(1);//一个元素，为空string
    * slist.assign(10,"Hi");//10个元素，每个都为“Hi”
  * swap
    * swap操作交换两个相同类型容器的内容
* 每个容器类型都支持相等运算符（==和！=），除无序关联容器外的所有容器都支持关系运算符（>、>=、<、<=）
  * 关系运算符左右两边的运算对象必须是相同类型的容器，且必须保存相同类型的元素。
  * 容器的关系运算符使用元素的关系运算符比较，只有当元素类型也定义了相应的比较运算符时，才可以使用关系运算符比较两个容器

___

#### 顺序容器操作