*   设计模式（原理及应用）
    *   单例模式
        *   适用性
            *   保证某个类只有一个实例，提供一个全局访问点
        *   实现（懒汉式为例）
            *   初始化并获得唯一实例的静态方法。
                *   private static Singleton uniqueInstance;
            *   私有构造函数防止在外部实例化。
                *   private Singleton() {}
            *   保存唯一实例的静态的私有变量。
                *   public static Singleton getInstance(){if(uniqueInstance==null){uniqueInstance==Singleton;} return uniqueInstance;}
        *   两种模式
            *   懒汉式
                *   类的唯一实例在真正调用时才被创建，而不是类加载时就被创建
                    *   程序见上面“实现”
            *   饿汉式
                *   在加载这个类时马上创建唯一的单件实例，就确保了任何线程访问uniqueInstance静态变量之前，一定先创建此实例。
                    *   程序
                        *   public class Singleton {
                        *   private static Singleton uniqueInstance = new Singleton();
                        *   private Singleton() {}
                        *   public static Singleton getInstance() {
                        *   return uniqueInstance;}}
        *   优点
            *   单例提供了全局唯一的访问入口，因此易于控制可能发生的冲突。单例是对类静态函数的一种改进，首先它避免了全局变量对系统的污染。如果将对象赋给一个全局变量，那么必须在程序一开始就创建好对象，若这个对象非常消耗资源，而程序在这次执行过程中又一直没有用到它，就形成了浪费；
            *   单例还可以延迟实例化，即只有在使用的时候才会实例化。
                
    *   工厂模式
        *   [Unity3d之设计模式（二）工厂模式\_Passion 的博客-CSDN博客\_unity 工厂模式](https://blog.csdn.net/yupu56/article/details/53669210)
        *   简单工厂模式
            *   UML类图
                *   *   ![](https://api2.mubu.com/v3/document_image/73aae9a1-1084-4242-b679-a60f39a8aa83-11312918.jpg)
                *   *   ![](https://api2.mubu.com/v3/document_image/e3aac670-1a3f-4e7b-90b8-93f2a9f7557d-11312918.jpg)
            *   实现意图
                *   简单工厂模式的实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类（这些产品类继承自一个父类或接口）的实例。
            *   角色职责
                *   SimpleFactory
                    *   工厂（Creator）角色：如上图中的SimplePizzaFactory类。简单工厂模式的核心，它负责实现创建所有实例的内部逻辑。工厂类可以被外界直接调用，创建所需的产品对象。
                *   Pizza
                    *   抽象（Product）角色：如上图中的Pizza抽象类。简单工厂模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口。
                *   *   具体产品（Concrete Product）角色：如上图中的CheesePizza类、VeggiePizza类和ClamPizza类。简单工厂模式的创建目标，所有创建的对象都是充当这个角色的某个具体类的实例。一般来讲它是抽象产品类的子类，实现了抽象产品类中定义的所有接口方法，也可以覆盖父类中的方法。
            *   特点
                *   优点
                    *   简单工厂模式的创建目标，所有创建的对象都是充当这个角色的某个具体类的实例。在这个模式中，工厂类是整个模式的关键所在。它包含必要的判断逻辑，能够根据外界给定的信息，决定究竟应该创建哪个具体类的对象。用户在使用时可以直接根据工厂类去创建所需的实例，而无需了解这些对象是如何创建以及如何组织的。有利于整个软件体系结构的优化。
                *   缺点
                    *   体现在其工厂类上，由于工厂类集中了所有实例的创建逻辑，所以"高内聚"方面做的并不好。另外，当系统中的具体产品类不断增多时，可能会出现要求工厂类也要做相应的修改，扩展性并不很好。
            
        *   工厂方法模式
            *   UML类图
                *   *   ![](https://api2.mubu.com/v3/document_image/97c0d0b4-4917-4b9f-9e91-9030c758f5c7-11312918.jpg)
            *   意图
                *   定义一个用户创建对象的接口，让子类决定实例化哪一个类，工厂方法模式使一个类的实例化延迟到其子类。
            *   适用性
                *   当一个类不知道它所必须创建的对象的类的时候。
                *   当一个类希望由它的子类来指定它所创建的对象的时候。
                *   当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候。
            *   优点
                *   Factory Method模式通过面向对象的手法，将所要创建的具体对象的创建工作延迟到了子类，从而提供了一种扩展的策略，较好的解决了这种紧耦合的关系。
                *   遵守了依赖倒置原则：要依赖抽象，不要依赖具体的类。为了避免违反依赖倒置原则，我们可以在设计中尽量遵守以下规定：1）变量不可以持有具体类的引用。如果使用new，就会持有具体类的引用，可以使用工厂来避免；2）不要让类派生自具体类。如果派生自具体的类，就会依赖具体类。请派生自一个抽象（接口或抽象类）；3）不要覆盖基类中已经实现的方法。如果覆盖基类已实现的方法，那么说明基类并不是一个真正适合被继承的抽象。
            
        *   抽象工厂模式
            *   UML类图
                *   *   ![](https://api2.mubu.com/v3/document_image/f9b7ed55-c737-4a4a-9b64-950c253bf1d1-11312918.jpg)
            *   意图
                *   提供一个接口，用于创建一系列相关或相互依赖对象的家族，而无需明确指定具体的类。与工厂方法类似，但此处返回的一系列相关产品。实现过程同样推延到子系列类去实现。与工厂方法的区别在于他们的层次模型。工厂方法的抽象基类只有儿子，而抽象工厂模式却是有孙子，而且每个儿子的儿子们之间有相互关联依赖关系。
            *   角色职责
                *   抽象工厂（Abstract Factory）：定义一个接口，声明生成一系列抽象产品的方法
                *   具体工厂（Concrete Factory）：执行生成一系列抽象产品的方法，生成一系列具体的产品
                *   抽象产品（Abstract Product）：为这一系列的某一种产品声明接口
                *   具体产品（Product）：定义具体工厂生成的具体产品的对象，实现产品接口
                *   客户（Client）：我们的应用程序客户端（不要理解成人），使用抽象产品和抽象工厂生成对象。
        *   小结
            *   简单工厂，工厂方法，抽象工厂都属于设计模式中的创建型模式。其主要功能都是帮助我们把对象的实例化部分抽取了出来，优化了系统的架构，并且增强了系统的扩展性。
        
    *   观察者模式
        *   概述
            *   定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖都会收到通知并自动更新。
        *   设计原则
            *   为了交互对象之间的松耦合设计而努力。观察者模式解除了主题和具体观察者的耦合，让耦合的双方都依赖于抽象，而不是依赖具体。从而使得各自的变化都不会影响另一边的变化。
            *   被观察者继承一个接口，这个接口包括：添加观察者、移除观察者、通知观察者触发事件。观察者继承一个接口，这个接口有个方法Update，在被观察者状态改变通知观察者时，调用的就是这个方法。观察者还要获取到被观察者的接口，用于注册，取消注册之类的事。
            *   开闭原则（扩展开放，修改关闭）
        *   UML类图
            *   *   ![](https://api2.mubu.com/v3/document_image/d779a80b-7953-48d5-856b-17b57dbd4f74-11312918.jpg)
        *   适用性
            *   当一个对象的改变需要给变其它对象时，而且它不知道具体有多少个对象有待改变时。
            *   一个抽象某型有两个方面，当其中一个方面依赖于另一个方面，这时用观察者模式可以将这两者封装在独立的对象中使它们各自独立地改变和复用。
                
        *   模式引申
            *   应用C#中的事件委托来彻底解除通知者和观察者之间的耦合
                *   关于委托的定义：委托是一种引用方法的类型。一旦为委托分配了方法，委托将与该方法有相同的行为。委托方法可以像其它任何方法一样，具有参数和返回值。委托可以看作是对函数（方法）的的抽象，是函数的“类”，委托的实例代表一个（或多个）具体的函数，它可以是多播的
                *   关于事件：事件基于委托，为委托提供了一种发布/订阅机制。事件的订阅与取消与我们刚才讲的观察者模式中的订阅与取消类似，只是表现形式有所不同。在观察者模式中，订阅使用方法Attach（）来进行；在事件的订阅中使用“+=”。类似地，取消订阅在观察者模式中用Dettach（），而事件的取消用“-=”。